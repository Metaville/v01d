// API/server.js  â€” ESM
import express from "express";
import cors from "cors";
import pg from "pg";

const { Pool } = pg;

/* ========= ENV ========= */
const PORT = process.env.PORT || 8080;
const DB_URL = process.env.DATABASE_URL;

const PLAYERS_TABLE = "v01dsql";
const EVENTS_TABLE  = "events";

// CORS: ÑÐ¿Ð¸ÑÐ¾Ðº Ð´Ð¾Ð¼ÐµÐ½Ð¾Ð² (Ñ‡ÐµÑ€ÐµÐ· Ð·Ð°Ð¿ÑÑ‚ÑƒÑŽ), Ð‘Ð•Ð— Ð·Ð°Ð²ÐµÑ€ÑˆÐ°ÑŽÑ‰ÐµÐ³Ð¾ /
// Ð¿Ñ€Ð¸Ð¼ÐµÑ€: FRONT_ORIGIN=https://v01d-production.up.railway.app,https://raw.githack.com
const ALLOWED_ORIGINS = (process.env.FRONT_ORIGIN || "")
  .split(",")
  .map(s => s.trim().replace(/\/$/, ""))
  .filter(Boolean);

// Telegram (Ð½ÐµÐ¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾, Ð½Ð¾ Ð¼Ð¾Ð¶Ð½Ð¾ Ð²ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ)
const TG_BOT_TOKEN = process.env.TG_BOT_TOKEN || "";
const TG_SECRET    = process.env.TG_SECRET || "";
const FRONT_URL    = (process.env.FRONT_URL || "https://v01d-production.up.railway.app").replace(/\/$/, "");

/* ========= DB ========= */
const pool = new Pool({
  connectionString: DB_URL,
  ssl: { rejectUnauthorized: false } // Railway PG Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾ Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ SSL
});

// ÑÐ¾Ð·Ð´Ð°Ð´Ð¸Ð¼ ÑÑ…ÐµÐ¼Ñ‹, ÐµÑÐ»Ð¸ Ð¸Ñ… Ð½ÐµÑ‚ (Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð½Ð¾)
async function ensureSchema() {

  // Extensions for UUID default
  try {
    await pool.query('CREATE EXTENSION IF NOT EXISTS pgcrypto');
  } catch (_) {
    try { await pool.query('CREATE EXTENSION IF NOT EXISTS "uuid-ossp"'); } catch(__) {}
  }
  await pool.query(`
    CREATE TABLE IF NOT EXISTS ${PLAYERS_TABLE}(
      id           BIGSERIAL PRIMARY KEY,
      telegram_id  BIGINT UNIQUE,
      sol_address  TEXT UNIQUE,
      callsign     TEXT,
      level        INTEGER DEFAULT 1,
      exp          INTEGER DEFAULT 0,
      resources    JSON   DEFAULT '{}'::json,
      progress     JSON   DEFAULT '{}'::json,
      stats        JSON   DEFAULT '{}'::json,
      settings     JSON   DEFAULT '{}'::json,
      last_login   TIMESTAMPTZ DEFAULT now(),
      created_at   TIMESTAMPTZ DEFAULT now()
    );
  `);

  await pool.query(`
    CREATE TABLE IF NOT EXISTS ${EVENTS_TABLE}(
      id         BIGSERIAL PRIMARY KEY,
      player_id  BIGINT REFERENCES ${PLAYERS_TABLE}(id) ON DELETE CASCADE,
      type       TEXT NOT NULL,
      payload    JSON DEFAULT '{}'::json,
      created_at TIMESTAMPTZ DEFAULT now()
    );
  `);

  
  // --- ensure default for id depending on its type (uuid or bigint) ---
  try {
    const q = await pool.query(
      `SELECT data_type, column_default
         FROM information_schema.columns
        WHERE table_name = $1 AND column_name = 'id'`,
      [PLAYERS_TABLE]
    );
    const row = q.rows[0] || {};
    const dataType = row.data_type;
    const hasDefault = !!row.column_default;

    if (!hasDefault) {
      if (dataType === 'uuid') {
        // prefer pgcrypto's gen_random_uuid(); fallback to uuid-ossp
        try {
          await pool.query(`ALTER TABLE ${PLAYERS_TABLE} ALTER COLUMN id SET DEFAULT gen_random_uuid()`);
        } catch(e1) {
          await pool.query(`ALTER TABLE ${PLAYERS_TABLE} ALTER COLUMN id SET DEFAULT uuid_generate_v4()`);
        }
      } else {
        // assume integer/bigint
        try {
          await pool.query(`ALTER TABLE ${PLAYERS_TABLE} ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY`);
        } catch (e) {
          await pool.query(`DO $$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = '${PLAYERS_TABLE}_id_seq') THEN
              EXECUTE 'CREATE SEQUENCE ${PLAYERS_TABLE}_id_seq OWNED BY ${PLAYERS_TABLE}.id';
            END IF;
            EXECUTE 'ALTER TABLE ${PLAYERS_TABLE} ALTER COLUMN id SET DEFAULT nextval(''${PLAYERS_TABLE}_id_seq'')';
          END $$;`);
        }
      }
    }
  } catch (e) {
    console.error("ensureSchema id default error:", e);
  }
}
ensureSchema().catch(e => {
  console.error("DB init error:", e);
  process.exit(1);
});

/* ========= APP ========= */
const app = express();
app.use(express.json({ limit: "1mb" }));

const corsOptions = {
  origin(origin, cb) {
    // Ð Ð°Ð·Ñ€ÐµÑˆÐ¸Ð¼ Ð¿ÑƒÑÑ‚Ð¾Ð¹ origin (health, Telegram webhook, curl)
    if (!origin) return cb(null, true);
    const o = origin.replace(/\/$/, "");
    if (!ALLOWED_ORIGINS.length || ALLOWED_ORIGINS.includes(o)) return cb(null, true);
    return cb(new Error("CORS"));
  },
  credentials: true,
  methods: ["GET","POST","PUT","PATCH","DELETE","OPTIONS"],
  allowedHeaders: ["Content-Type","Authorization","X-Requested-With","X-Telegram-Bot-Api-Secret-Token" , 'X-Telegram-Init']
};

app.use(cors(corsOptions));
app.options("*", cors(corsOptions)); // Ð¿Ñ€ÐµÑ„Ð»Ð°Ð¹Ñ‚ Ð½Ð° Ð²ÑÑ‘

// Ð´Ñ€ÑƒÐ¶ÐµÐ»ÑŽÐ±Ð½Ð°Ñ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° CORS-Ð¾ÑˆÐ¸Ð±ÐºÐ¸
app.use((err, req, res, next) => {
  if (err && err.message === "CORS") return res.status(403).json({ ok:false, error:"CORS" });
  return next(err);
});

/* ========= ROUTES ========= */

// health
app.get("/api/health", async (_, res) => {
  try {
    await pool.query("SELECT 1");
    res.json({ ok: true });

// player by telegram id (for a quick existence check)
app.get("/api/player/by-tg/:tg", async (req, res) => {
  try {
    const tg = req.params.tg;
    if (!tg || !/^\d+$/.test(tg)) return res.status(400).json({ ok:false, error:"bad_telegram_id" });
    const q = await pool.query(
      `SELECT id, telegram_id, sol_address, callsign, level, exp, resources, progress, stats, created_at, last_login
       FROM %s WHERE telegram_id = $1`.replace('%s', PLAYERS_TABLE),
      [tg]
    );
    if (!q.rowCount) return res.status(404).json({ ok:false, error:"not_found" });
    return res.json({ ok:true, player: q.rows[0] });
  } catch (e) {
    console.error("by-tg error:", e);
    return res.status(500).json({ ok:false, error:"server_error" });
  }
});
  } catch (e) {
    console.error("health db:", e);
    res.status(500).json({ ok:false });
  }
});

/**
 * /api/player/sync
 * ÐŸÑ€Ð¸Ð½Ð¸Ð¼Ð°ÐµÑ‚:
 *  telegramId?  (number)
 *  solAddress?  (string)
 *  callsign?    (string)
 *  level?       (number)
 *  exp?         (number)
 *  resources?   (json)
 *  progress?    (json)
 *  stats?       (json)
 *
 * Ð¢Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ð¼Ð¸Ð½Ð¸Ð¼ÑƒÐ¼ Ð¾Ð´Ð½Ð¾ Ð¸Ð·: telegramId Ð˜Ð›Ð˜ solAddress
 *
 * Ð ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ â€” UPDATE â†’ ÐµÑÐ»Ð¸ 0 ÑÑ‚Ñ€Ð¾Ðº, Ñ‚Ð¾ INSERT (Ð±ÐµÐ· ON CONFLICT),
 * Ð¿Ð¾ÑÑ‚Ð¾Ð¼Ñƒ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ñ Ð»ÑŽÐ±Ñ‹Ð¼ Ñ‚ÐµÐºÑƒÑ‰Ð¸Ð¼ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸ÐµÐ¼ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹.
 */
app.post("/api/player/sync", async (req, res) => {
  const b = req.body || {};
  const telegramId = (b.telegramId ?? b.telegram_id ?? null);
  const solAddress = (b.solAddress ?? b.sol_address ?? null);

  if (!telegramId && !solAddress) {
    return res.status(400).json({ ok:false, error:"Need telegramId or solAddress" });
  }

  const callsign  = b.callsign ?? "Citizen";
  const level     = Number.isFinite(+b.level) ? +b.level : 1;
  const exp       = Number.isFinite(+b.exp)   ? +b.exp   : 0;
  const resources = b.resources ?? {};
  const progress  = b.progress  ?? {};
  const stats     = b.stats     ?? {};

  const client = await pool.connect();
  try {
    await client.query("BEGIN");
    let row;

    if (telegramId) {
      // 1) UPDATE Ð¿Ð¾ telegram_id
      const upd = await client.query(
        `
        UPDATE ${PLAYERS_TABLE} SET
          sol_address = COALESCE($2, sol_address),
          callsign    = COALESCE($3, callsign),
          level       = GREATEST(level, $4),
          exp         = GREATEST(exp,   $5),
          resources   = COALESCE($6::json, resources),
          progress    = COALESCE($7::json, progress),
          -- ÑÐ»Ð¸ÑÐ½Ð¸Ðµ JSON: json -> jsonb -> json
          stats       = (COALESCE(stats, '{}'::json)::jsonb || COALESCE($8::json, '{}'::json)::jsonb)::json,
          last_login  = now()
        WHERE telegram_id = $1
        RETURNING id, telegram_id, sol_address, callsign, level, exp, resources, progress, stats, created_at, last_login;
        `,
        [telegramId, solAddress, callsign, level, exp, resources, progress, stats]
      );

      row = upd.rows[0];

      // 2) Ð•ÑÐ»Ð¸ Ð½ÐµÑ‚ â€” INSERT
      if (!row) {
        const ins = await client.query(
          `
          INSERT INTO ${PLAYERS_TABLE}
            (telegram_id, sol_address, callsign, level, exp, resources, progress, stats, last_login)
          VALUES ($1, $2, $3, $4, $5, $6::json, $7::json, $8::json, now())
          RETURNING id, telegram_id, sol_address, callsign, level, exp, resources, progress, stats, created_at, last_login;
          `,
          [telegramId, solAddress, callsign, level, exp, resources, progress, stats]
        );
        row = ins.rows[0];
      }
    } else {
      // Ð’ÐµÑ‚ÐºÐ° Ð±ÐµÐ· telegramId â€” Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÐ¼ Ð¿Ð¾ sol_address
      const upd = await client.query(
        `
        UPDATE ${PLAYERS_TABLE} SET
          callsign    = COALESCE($2, callsign),
          level       = GREATEST(level, $3),
          exp         = GREATEST(exp,   $4),
          resources   = COALESCE($5::json, resources),
          progress    = COALESCE($6::json, progress),
          stats       = (COALESCE(stats, '{}'::json)::jsonb || COALESCE($7::json, '{}'::json)::jsonb)::json,
          last_login  = now()
        WHERE sol_address = $1
        RETURNING id, telegram_id, sol_address, callsign, level, exp, resources, progress, stats, created_at, last_login;
        `,
        [solAddress, callsign, level, exp, resources, progress, stats]
      );

      row = upd.rows[0];

      if (!row) {
        const ins = await client.query(
          `
          INSERT INTO ${PLAYERS_TABLE}
            (sol_address, callsign, level, exp, resources, progress, stats, last_login)
          VALUES ($1, $2, $3, $4, $5::json, $6::json, $7::json, now())
          RETURNING id, telegram_id, sol_address, callsign, level, exp, resources, progress, stats, created_at, last_login;
          `,
          [solAddress, callsign, level, exp, resources, progress, stats]
        );
        row = ins.rows[0];
      }
    }

    await client.query("COMMIT");
    return res.json({ ok:true, player: row });
  } catch (e) {
    await client.query("ROLLBACK");
    console.error("sync 500:", e);
    return res.status(500).json({ ok:false, error:"server_error" });
  } finally {
    client.release();
  }
});

// ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ (Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ â€” ÐµÑÑ‚ÑŒ ensureSchema)
app.post("/api/events", async (req, res) => {
  try {
    const { playerId, type, payload = {} } = req.body || {};
    if (!playerId || !type) return res.status(400).json({ ok:false, error:"bad_request" });

    const q = await pool.query(
      `INSERT INTO ${EVENTS_TABLE} (player_id, type, payload) VALUES ($1,$2,$3::json)
       RETURNING id, created_at`,
      [playerId, type, payload]
    );
    res.json({ ok:true, id: q.rows[0].id, created_at: q.rows[0].created_at });
  } catch (e) {
    console.error("events error:", e);
    res.status(500).json({ ok:false, error:"server_error" });
  }
});

// Telegram webhook
app.post("/api/tg/webhook", async (req, res) => {
  try {
    // Ð² Ð¿Ñ€Ð¾Ð´Ðµ Ð»ÑƒÑ‡ÑˆÐµ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÑ‚ÑŒ ÑÐµÐºÑ€ÐµÑ‚
    const hdr = req.get("X-Telegram-Bot-Api-Secret-Token");
    if (TG_SECRET && hdr !== TG_SECRET) return res.sendStatus(401);

    const u = req.body;
    if (u?.message && TG_BOT_TOKEN) {
      const chatId = u.message.chat.id;
      const text = (u.message.text || "").trim();

      if (text === "/start" || text.startsWith("/start")) {
        const resp = await fetch(`https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage`, {
          method: "POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify({
            chat_id: chatId,
            text: "ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð¸Ð³Ñ€Ñƒ ðŸ‘‡",
            reply_markup: {
              inline_keyboard: [[
                { text: "Metaville", web_app: { url: FRONT_URL } }
              ]]
            }
          })
        });
        const body = await resp.text();
        if (!resp.ok) console.error("TG sendMessage failed:", resp.status, body);
        else          console.log("TG sendMessage ok");
      }
    }
    res.sendStatus(200);
  } catch (e) {
    console.error("tg webhook error:", e);
    res.sendStatus(200);
  }
});

// ÐºÐ¾Ñ€ÐµÐ½ÑŒ â€” Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ°
app.get("/", (_, res) => res.type("text/plain").send("Metaville API is running"));

/* ========= START ========= */
app.listen(PORT, "0.0.0.0", () => console.log("API on :", PORT));
